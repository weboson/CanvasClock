
//! Суть цикла "window.requestAnimationFrame(callback);":
//! 1 -- один "Clock" метод находится в цикле, благодаря методу браузера "window.requestAnimationFrame(callback);"
//! 2 -- Чтобы замкнуть цикл, нужно в callback (Clock) также вызвать "window.requestAnimationFrame(callback);"
//! 2 -- "window.requestAnimationFrame(callback);" будет вызывать Callback (Clock) 60 раз в секунду (т.е. столько, сколько частота монитора)

//!Суть анимации (важно помнить что АНИМАЦИЯ ЭТО ЦИКЛ КАДРОВ)
//! 1 -- Очистить canvas (холст) полностью весь (ctx.clearRect(0,0,500,500)) - от предудущей анимации (позиции стрелок)
//! 2 -- В каждом цикле рисовать циферблат
//! 3 -- В каждом цикле рисовать новую позцию стрелки
//! 4 -- НО чтобы, новая позиция стрелки, высчитывалась с изночально, то есть с 0, а не с предыдущей позции стрелки
//! 5 -- Мы сохраняем НУЛЕВУЮ (изначальную, первую) позцию стрелки - save()
//! 6 -- И после смены позции стрелки, востанавливаем в НУДЕВОЕ ПОЛОЖЕНИЕ - restore()

//! грубо говоря об анимации:
//! 1 -- анимация в цикле
//! 2 -- в каждой итерации мы сначала очищаем canvas (от предыдущей анимации)
//! 3 -- в каждой итерации мы ресуем новую позцию стрелки 
//! 4 -- не зыбывем указать точку отсчета для переворачивания (анимации) стрелки - save() и resore()


let сanvas = document.querySelector('#canvas');
let ctx = canvas.getContext('2d');

function draw() {   
    if (canvas.getContext){ // проверка на поддержку canvas
// просит браузер запланировать перерисовку на следующем кадре анимации. 
// В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой.
//! callback метод сам должен вызвать requestAnimationFrame() иначе анимация остановится.
         window.requestAnimationFrame(clock);
      } 
}  


//! метод радиального расчета (degrees) - необходимые градусы 
function getRadians(degrees) {
    return (Math.PI / 180) * degrees;
  } 



function clock() {
//! каждый раз очищать предыдущий рендеринг в цикле
  ctx.clearRect(0,0,500,500); // clear canvas
//! сохранить
  ctx.save();


  //! -------------ЦИФЕРБЛАТ-------------------
  //! *********нарисуем (голубую) окружность
    //     ctx.arc(
    //       250, // x - позиция точки
    //       50, // y - позиция точки 
    //       20 // радиус
    //       (3 *Math.PI) / 2, // радиальный  угол - начало дуги (по таблице ось Y наоборот)
    //       true // -> против часовой стрелки --- а по умолчанию (или false) по часовой стрелки
    //        );
    ctx.translate(250, 250); // переместили холст (саму ось) по центру круга    
    ctx.beginPath(); // создадим путь
    ctx.arc(0, 0, 200, 0, 360); 
    ctx.strokeStyle = 'rgb(89, 189, 255)' // цвет контура
    ctx.lineWidth = '3'// ширина контура
    ctx.stroke(); // заливка контура, иначе не увидеть фигуру


  //! ***********создадим 60 шкал
  // в уме: окружность радиусом 200
  //! цикл постройки всех 60-ти шкал
  for(let i = 0; i <= 60; i++) { // 60 раз нарисовать шкалу (60 секудн)
    // поворот шкалы по окуржности
    //! порядок важен
    ctx.strokeStyle = 'black' // цвет контура
    // поворот по оси (в радианах)
    ctx.rotate((Math.PI / 180) * 6); // 60 шкал с интервалом по 6 пискселей между ними
    ctx.beginPath();
    ctx.moveTo(160,0); // точка пера
    ctx.lineTo(190,0); // линия до указанной координатной точки
    ctx.stroke(); // заливка 

  }

//! воссстановливать пустой (без стрелки) циферблат
ctx.restore()

//! -------------СТРЕЛКА СЕКУНДНАЯ-------------

  ctx.strokeStyle = 'red' // цвет контура стрелки
//! сохранил состояние все что было до него, 
//! и так как в конце (цикла) постянный сброс (restore),
//! соответсвенно сохранятся будет пустой циферблат, 
//! с нудевой позицией холста
//! и очередное перевертываение стрелки (например 60 - ctx.rotate(getRadians(60)))
//! будет отсчет с НУЛЕВОЙ ПОЗИЦЕЙ.
//! 0 + 10, 0 + 20, 0 + 30, 0 + 40 И ТАК ДВИЖЕТСЯ (рисуется) СТРЕЛКА ПО 10

ctx.save() // сохранить ПОЗИЦИЯ ХОЛСТА (rotate(270гр.))


// переместили холст (саму ось) по центру круга
  ctx.translate(250, 250);  //! ДЛЯ СТРЕЛКИ

  //окружность радиусом 200

  // секунды
  let sec = new Date().getSeconds()
 // повернем холст вместе со стрелкой   
// 90 чтобы стрелка была повернута как на часах 0 это  270 градусов  
      ctx.rotate(getRadians((sec * 6) - 90) ); // 60 шкал с интервалом по 6 пискселей между ними

      ctx.beginPath();
      
      ctx.moveTo(0,0); // точка пера в центре холста (круга)
      ctx.lineTo(130,0); // линия до указанной координатной точки
      ctx.stroke(); // заливка 

//! восстановить состояние до save() - пустой циферблат часов
      ctx.restore();  
//! запустить в цикл
  window.requestAnimationFrame(clock);
}


